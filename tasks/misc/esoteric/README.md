# Отборочный этап Кубка CTF России 2020

## Misc | Esoteric

### Описание

> Вам тоже наскучили эти старомодные языки программирования?
> 
> Я придумал новый эзотерический язык и уже написал к нему интерпретатор.
> 
> Запустите на нём программу для получения флага.
> 
> `nc IP 7704`

### Хинт

> Не нужно использовать полный перебор, чтобы найти нужный seed. Это неэффективно, особенно для длинных строчек (придётся перебрать примерно `100^n`, где n — длина строки).
> 
> Попробуйте разобраться в том, как работает функция `random.choices` внутри, чтобы руками построить нужный seed. 

### Выдаваемые файлы

- [esoteric.py](service/esoteric.py)
- [Dockerfile](service/Dockerfile)

### Решение

Эзотерических языков настолько много, что даже настолько безумная идея уже была придумана ранее. Таск вдохновлён языком [Seed](https://esolangs.org/wiki/Seed), хотя и немного отличается от него.

Нужно сделать простую вещь: найти нужный `seed` для генератора случайных чисел в Python 3.7, чтобы генерируемая последовательность чисел превратилась в код на питоне, который потом исполнит `eval()`.

В Python 3.7 используется [Mersenne Twister](https://ru.wikipedia.org/wiki/Вихрь_Мерсенна) (MT19937), а его реализация доступна в [исходниках на GitHub](https://github.com/python/cpython/blob/3.7/Modules/_randommodule.c).

Для начала нужно понять, как работает `random.choices()` ([вот её код](https://github.com/python/cpython/blob/225e3659556616ad70186e7efc02baeebfeb5ec4/Lib/random.py#L344)). Внутри она использует функцию `random.random()` ([её исходный код](https://github.com/python/cpython/blob/225e3659556616ad70186e7efc02baeebfeb5ec4/Modules/_randommodule.c#L131)), которая возвращает число с плавающей точкой. Это число затем умножается на размер коллекции, чтобы определить случайный элемент.

Внутри MT19937 устроен довольно просто: у него есть состояние (`state`) — массив размера `N = 624` и счётчик (`index`). На каждый запрос случайного 32-битного числа возвращается `state[index]` (с некоторыми преобразованиями), и `index` инкрементируется. Если `index` дошёл до `N`, производится пересчёт массива `state`. Соответственно, нам нужно установить определённый `state`, чтобы он выдавал нужные нам числа.

Код инициализации генератора находится в функции `random_seed`, но нас интересует функция `init_by_array` ([вот она](https://github.com/python/cpython/blob/225e3659556616ad70186e7efc02baeebfeb5ec4/Modules/_randommodule.c#L168)), именно эта функция отвечает за инициализацию генератора из массива 32-битных чисел (а именно в такой массив превращаются целые числа в Python, если их передать в функцию `random_seed`). Нужно прочитать эту функцию написать обратную к ней.

Также стоит обратить внимание на код, который производит генерацию 32-битных чисел из массива `state` ([вот он](https://github.com/python/cpython/blob/225e3659556616ad70186e7efc02baeebfeb5ec4/Modules/_randommodule.c#L96)). Но этого можно не делать, так как в интернете полно статей про то, как восстанавливать и обращать состояние MT19937.

После того, как мы научимся генерировать нужный `seed`, можно исполнить, например, вот такой код:

```python
exec(input())
```

а затем ввести код, который вызовет шелл:

```python
import os; os.system("sh")
```

__Пример решения: [exploit.py](exploit.py)__

### Флаг

`ctfcup{mt19937_1n_2O2O_str1k3s_b4ck_4g41n}`
