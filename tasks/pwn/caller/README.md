# Отборочный этап Кубка CTF России 2020

## Pwn | Caller

### Описание

> Что может сделать всего один маленький системный вызов?
> 
> Если вы получите RCE с его помощью, я выдам вам флаг.
> 
> Вернее, вы сами его заберёте.
> 
> `nc IP 7703`

### Выдаваемые файлы

- [caller.py](service/caller.py)
- [Dockerfile](service/Dockerfile)

### Решение

Программа исполняет любой системный вызов с любыми аргументами, используя функцию `syscall` из libc.

Я предполагаю, что мой способ решения не единственный и вряд ли самый простой. Будем использовать особенности внутреннего строения языка Python, а именно особенности реализации целых чисел.

В Python использование небольших чисел (от `-5` до `256` включительно) не приводит к созданию новых объектов чисел. Вместо этого используются заранее созданные объекты чисел:

```python
>>> hex(id(100))
'0xaa7400'
>>> hex(id(101))
'0xaa7420'
>>> hex(id(100 + 1))
'0xaa7420'
>>> hex(id(1000))
'0x7f6664bfbb30'
```

При этом у каждого числа (как и у любого другого объекта в Python) хранится счётчик ссылок на этот объект, этот счётчик располагается в первом поле структуры объекта. Так, например, если `id(100) == 0xaa7400`, то по адресу `0xaa7400` лежит число, равное числу ссылок на объект числа `100`.

Для начала заметим, что мы можем посылать неограниченное количество аргументов для функции `syscall`, а значит, мы также можем послать любое количество одинаковых чисел. Например, если мы отправим 1000 чисел `100`, то счётчик ссылок на `100` увеличится на 1000. С помощью этого метода мы сможем записывать нужные данные в начало структуры числа.

Затем вспомним, что у всех объектов в Python есть таблица стандартных методов (таких как `str`, `add` и т.д.), ссылки на которые хранятся в структуре типа. У целых чисел описывающий их тип — `PyLong_Type` (его реализацию можно посмотреть в [репозитории Python 3.7](https://github.com/python/cpython/blob/3.7/Objects/longobject.c)). Важно, что сервис нам печатает возвращаемое значение системного вызова, а возвращаемое значение системного вызова — всегда целое число. Это значит, что в этот момент целое число переводится в строку, а значит применяется какая-то функция, которая принимает число первым аргументом (а именно `long_to_decimal_string`, [она же в репозитории](https://github.com/python/cpython/blob/3.7/Objects/longobject.c#L1762)). В бинарнике `python3.7` как раз есть функция `system`, поэтому мы сможем заменить нужную нам функцию в структуре целого числа, используя системный вызов `read`.

План эксплуатации такой:

1. находим в бинарнике адрес структуры `PyLong_Type`
2. находим в бинарнике указатель на `long_to_decimal_string` (смещение в структуре `PyLong_Type`), назовём его `PyLong_ToString`
3. находим в бинарнике адрес функции `system` в PLT
4. вызываем `read(0, PyLong_ToString, 8)` и перезаписываем указатель на `system`
5. возвращаемое значение системного вызова равно `8`, поэтому при переводе числа в строку вызовется `str(8)`, с учётом нашей замены это будет `system(id(8))`
6. чтобы по адресу `id(8)` лежала какая-то команда (например, `sh`), нужно дописать к аргументам системного вызова нужное количество восьмёрок (с учётом замечания, описанного выше), они все равно проигнорируются функцией `syscall`

__Пример решения: [exploit.py](exploit.py)__

### Флаг

`ctfcup{w3ll_d0n3_d34r_pyth0n_h4ck3r}`
